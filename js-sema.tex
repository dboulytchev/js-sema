% !TEX TS-program = pdflatex
% !TeX spellcheck = en_US
% !TEX root = uigen.tex
\documentclass{article}

\usepackage{graphicx}
%\usepackage{tikz}
%\usetikzlibrary{shapes.geometric,backgrounds,
%  positioning-plus,node-families,calc}
\usepackage{xcolor}
\usepackage{amsfonts}
\usepackage{mathtools}
\usepackage{hyperref}
\usepackage{marginnote}
\usepackage{verbatim}
\usepackage{listings}
\usepackage{amsmath,mathrsfs,amssymb}
\usepackage{placeins}
\usepackage{textcomp}
\usepackage{xspace}


\lstdefinelanguage{js}{
keywords={for, in, delete, let, function, if, else, return, var, true, this, new},
sensitive=true,
commentstyle=\small\itshape\rmfamily,
keywordstyle=\bfseries\rmfamily,
identifierstyle=\rmfamily,
basewidth={0.5em,0.5em},
columns=fixed,
fontadjust=true,
literate={->}{{$\to$}}3 {===}{{$\equiv$}}1 {=/=}{{$\not\equiv$}}1 {|>}{{$\triangleright$}}3 {|||}{{$\vee$}}2 {/\\}{{$\wedge$}}2 {^}{{$\uparrow$}}1,
morecomment=[s]{(*}{*)}
}

\lstset{
mathescape=true,
basicstyle=\small,
%identifierstyle=\ttfamily,
%keywordstyle=\bfseries,
%commentstyle=\scriptsize\rmfamily,
basewidth={0.5em,0.5em},
fontadjust=true,
language=js
}

\newcommand{\term}[1]{\mbox{\texttt{\textbf{#1}}}}
\newcommand{\run}[2]{\term{run}^{#1}\,\left[#2\right]}
\newcommand{\todo}[1]{{\bf\color{red}#1}}
\newcommand{\rel}[3]{{#1}\xrightarrow{#2}{#3}}
\newcommand{\prg}[1]{\mbox{\lstinline|#1|}}
\newcommand{\precprec}{\prec\mathrel{\mkern-5mu}\prec}

\newcommand{\grc}[2]{{#1}\,\left<{#2}\right>}
\newcommand{\java}[1]{\texttt{#1}}
\newcommand{\primi}[1]{\mathbf{#1}}
\newcommand{\cc}[1]{\lfloor{#1}\rfloor}
\newcommand{\js}{\textsc{JavaScript}\xspace}
\newcommand{\es}{\textsc{ECMAScript}\xspace}
\newcommand{\ecma}{\textsc{Ecma International}\xspace}
\newcommand{\rf}[1]{[\textsc{#1}]}
\sloppy
\date{}
\begin{document}

\title{Undestanding \js Semantics}

\author{Peter Lozov, Dmitri Kosarev, Dmitri Boulytchev}
%{St.Petersburg State University \\ 
%  Saint-Petersburg, Russia }
%{$\mathtt{Dmitrii.Kosarev@protonmail.ch}$ \and $\mathtt{dboulytchev@math.spbu.ru}$}

\maketitle

\begin{abstract}
  In this document we discuss the pecularities of \js semantics and give some
  guidelines which would help to navigate through and understand the relavant
  literature.
\end{abstract}

\section{Introduction}

\js is a general-purpose language which serves as a \emph{de-facto} standard for web-based
applications development. Historically, \js was developed and released in the middle of 1990s
as a mean to add dynamicity to web-pages. Language-wise, \js is an imperative object-oriented
dynamically typed language with first-class functions and objects. Currently \js is
supported by all mainstream web-browsers via different implementations: \textsc{V8}~\cite{V8}
for \textsc{Chrome}-based browsers, \textsc{Chakra}~--- for \textsc{Microsoft Edge},
\textsc{SpiderMonkey}~\cite{SpiderMonkey}~--- for \textsc{Mozilla Firefox} and some others, and,
finally, \textsc{JavaScriptCore}~\cite{JavaScriptCore} for \textsc{Safari}.

Nowdays \js is a full-fledged general-purpose programming language which possesses a number of
somewhat unique properties. While for a regular web programming it is often sufficient to
stick with a number of tutorials~\cite{Tutorial} developing \emph{tools} require a
much greater level of internalization of \js semantics. This document provides some
introduction to \js pecular features, references to relevant documentation and
some guidelines for its reading and understanding.

The principal source of information on \js is the specification~\cite{Spec} which is maintained by
\ecma~--- an European standartization organization in the domain of informatics and telecommunications.
The specification spans over 800 pages and is intended to be self-sufficient. For this purpose
the first sections introduce the terminological and typographical conventions used throuhout the rest of
the specification as well as algorithmic notation for specifying the semantics of some built-in operations
and procedures. However being written in a natural language the specification is verbose and hardly admits
a formal treatment. For this purpose a number of attempts to re-formulate the semantics of the language
in more conventional terms were taken. In~\cite{Operational1,Operational2} a small-step operational
semantics is given for a reasonably chosen subset of the language and some safety properties for
\js programs are proven. The resulting formal semantics (as reported by the authors) occupies 70 pages of
ASCII code. The papers also investigate the differences in implementations; for example, the following
program

\begin{lstlisting}
   var f =
     function () {
       if (true) {function g () {return 1}}
       else      {function g () {return 2}};
       
       function g () {return 3};
    
       return g ();
    
       function g () {return 4}
     };
\end{lstlisting}

is reported to behave differently (as per moment of writing) under different implementations due to their
different one- vs. multi-pass architectures. The function definitions in \es are \emph{hoisted} (order-preserving
moved to the top of the scope they are declared in), thus the last definition of ``\lstinline|g|'' shadows
all others, which is not always respected by the implementations.

Another attempt is taken in~\cite{Trusted,JSCert} where a certified implementation of \js in \textsc{Coq} is
presented. The development is accompanied with an extracted reference interpreter and a number of tests. The
results reported are reproducible after a reasonal amount of efforts~\cite{JSCert-lozov}.

It's worth noticing that both mentioned results deal with minor versions of \es (\es-4 and \es-5 respectively), thus
they do not support some more recent features of the language such as, for example, classes. Moreover, even
within the addressed standard not all features are supported which makes their direct usage as a reference
implementation problematic.

In the subsequent sections we address some properties of \js semantics which we consider the most interesting; we
label the description with the exact references to the \es specification given in a \rf{designated} form.

\section{Objects}
\label{sec:model}

Objects~\rf{6.1.7} constitute the most important kind of values \js programs operate with. In a nutshell, objects are
finite collections of \emph{properties}. The specification makes a distinction between \emph{data} properties and \emph{accessor}
properties. Each property posesses a \emph{key} which in fact can be a \emph{symbol}
(indentifier), a string or an integer, and a \emph{value} which is a regular \js value. Thus, objects are finite maps.
In order to make it possible to specify objects explicitly \js introduces a dedicated notation~--- JSON (\js Object Notation).
For example, in the following snippet

\begin{lstlisting}
    let obj = {name: "object"; id : 1};
\end{lstlisting}

an explicit object with two properties named ``\lstinline|name|'' and ``\lstinline|id|'' with values \lstinline|"object"| and
\lstinline|1| respectively is defined; a reference to this object is placed in the variable \lstinline|obj|.

The essential property of \js objects is their dynamic nature. Properties can be added, removed, and modified at a runtime.
In the context of the previous example one can make

\begin{lstlisting}
    obj.name = 3;
    obj.kind = "new property example";
    delete obj.id;
\end{lstlisting}

changing the value (and a type) of the property ``\lstinline|name|'', adding a new property ``\lstinline|kind|'' with
corresponding value and deleting the property ``\lstinline|id|''. Additionally, each property is equipped with a set
of \emph{attributes}~\rf{6.1.7.1} which controls what operations are permitted for this property. These attributes can
be set at a runtime, too. 

The specification distinguishes \emph{ordinary}~\rf{10.1} objects from \emph{exotic}~\rf{10.4} ones. The difference between the
two lays in different behaviour of some built-in operations. For example, arrays ans strings are exotic since they
accept integers as names for their properties.

All objects form a hierarchy via a \emph{prototype} inheritace (see Section~\ref{sec:prototype}). The basis of
this hierarchy is \lstinline|Object| object~\rf{20.1} which defines the properties common for all objects.
In the context of previous example one may perform a call

\begin{lstlisting}
    obj.toString ()
\end{lstlisting}

although "\lstinline|obj|" does not possess ``\lstinline|toString|'' as its own property. This property is ``borrowed''
from \lstinline|Object|. The call returns string \lstinline|"[object Object]"| in a full accordance with the
specification~\rf{20.1.3.6}.

The language is equipped with a control construct~\rf{14.7.5} which, in particular, allows for iterating over
all properties of objects. For example the construct

\begin{lstlisting}
    for (let p in obj) {
      ...
    }
\end{lstlisting}

goes over all \emph{own} properties of an object ``\lstinline|obj|'', binding identifier ``\lstinline|p|'' to the
name of a property on each iteration. The property's value then can be accessed via construct ``\lstinline|obj [p]|''.

\section{Functions, Constructors, and Prototypes}
\label{sec:prototype}

\js equipped with full-fledged first-class functions with closures. Beside that, however, functions possess a number of pecularities.

First, functions are regular objects. For example, given a definition

\begin{lstlisting}
    let f = function (x) {return x;};
\end{lstlisting}

one may make a call

\begin{lstlisting}
    f.toString ()
\end{lstlisting}

which returns a string ``\lstinline|function (x) {return x;}|''. Since (as is it rather natural to anticipate) ``\lstinline|toString|''
is a function it can be called on itself

\begin{lstlisting}
    f.toString.toString ()
\end{lstlisting}

which returns ``\lstinline|function toString() { [native code] }|''. Function objects~\rf{20.2} occupy a dedicated place in objects' hierarchy
and share a number of common properties. For example

\begin{lstlisting}
    f.length
\end{lstlisting}

gives a number of arguments which function ``\lstinline|f|'' accepts.

Then, functions play role of \emph{constructors}~\rf{6.1.7.2}. For example, the following definition

\begin{lstlisting}
    function Person (name, age, address) {
      this.name    = name;
      this.age     = age;
      this.address = address;
    }
\end{lstlisting}

allows for creating a similarly structured objects \emph{en masse}:

\begin{lstlisting}
    let Alice      = new Person ("Alice", 12, "Wonderland");
    let MadHatter  = new Person ("Mad Hatter", undefined, "Tea Party");  
\end{lstlisting}

It is worth mentioning that there is nothing special about function ``\lstinline|Person|'' in
comparison with other functions. Its role as a constructor is primarily conventionalized
by a usage together with the construct ``\lstinline|new|''. Internally, \js sometimes can
tell constructor functions apart from non-constructor ones (for example, for built-in functions or
functions explicitly defined as class construtors), but for regular user-defined functions
it can not do this. Therefore, there is nothing wrong with a plain call

\begin{lstlisting}
    let x = Person ("Global Object", 0, "Right Here");
\end{lstlisting}

However, in this case corresponding properties will be added or set for the \emph{global object}~\rf{19} by
the discipline of binding for ``\lstinline|this|'' (see Section~\ref{sec:this}).

Similarly, a function

\begin{lstlisting}
    function foo (x, y) {return x+y;}
\end{lstlisting}

can be coupled with ``\lstinline|new|'':

\begin{lstlisting}
    let p = new foo (2, 3);
\end{lstlisting}

The result associated with ``\lstinline|p|'', however, will be an empty \lstinline|Object| rather then number 5.

Finally, function objects posess a property called ``\lstinline|prototype|'' which is used for implementing
inheritance. Each object holds an implicit reference to the the object referenced by ``\lstinlie|prototype|''
property of a constructor this object was created by. 


\section{The Magic of ``\lstinline[basicstyle=\normal]|this|''}
\label{sec:this}

\section{Mixins}

\begin{thebibliography}{99}
\bibitem{Spec}
  \es\textsuperscript{\textregistered} 2025 Language Specification. Draft ECMA-262, March 7, 2024 //
  \url{https://tc39.es/ecma262/}
\bibitem{Operational1}
  Sergio Maffeis, John C. Mitchell, Ankur Taly. An Operational Semantics for \js. // Asian Symposium on Programming Languages and Systems, 2008, pp.~307-325,
  \url{https://seclab.stanford.edu/websec/jsPapers/aplas08-camera-ready.pdf}
\bibitem{Operational2}
  Sergio Maffeis, John C. Mitchell, Ankur Taly. An Operational Semantics for \js, revised and extended version // \url{http://jssec.net/semantics/sjs.pdf}
\bibitem{Trusted}
  Martin Bodin, Arthur Chargueraud, Daniele Filaretti, Philippa Gardner, Sergio Maffeis, Daiva Naudziuniene, Alan Schmitt, Gareth Smith. A Trusted Mechanised \js Specification //
  POPL'14: Proceedings of the 41st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, January 2014, pp.~87–100.
\bibitem{JSCert}
  A Coq Specification of \es~5 (\js) with Verified Reference Interpreter // \url{jscert.org}
\bibitem{JSCert-lozov}
  A Coq Specification of \es~5 (\js) with Verified Reference Interpreter, reflections on building, installation, and run // \url{https://github.com/Lozov-Petr/jscert}  
\bibitem{Ecma} \ecma. Industry Association for Standardizing Information and Communication Systems // \url{https://ecma-international.org}
\bibitem{Chakra} \textsc{ChakraCore} project website // \url{https://github.com/chakra-core/ChakraCore}
\bibitem{SpiderMonkey} \textsc{SpiderMonkey} project website // \url{https://spidermonkey.dev}
\bibitem{V8} \textsc{V8} project website // \url{https://chromium.googlesource.com/v8/v8}
\bibitem{JavaScriptCore} \textsc{JavaScriptCore} project website // \url{https://docs.webkit.org/Deep%20Dive/JSC/JavaScriptCore.html}
\bibitem{Tutorial} \js Tutorial // \url{https://www.w3schools.com/js/}
\end{thebibliography}

\end{document}

